# Complete Flask App with Account Creation and Management
from flask import Flask, render_template, request, redirect, url_for, session, flash, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
import sqlite3
from datetime import datetime, timedelta
import os
from functools import wraps
import secrets

app = Flask(__name__)
app.secret_key = 'your-secret-key-change-this-in-production'
app.permanent_session_lifetime = timedelta(days=30)

# Database initialization
def init_db():
    conn = sqlite3.connect('foodfixr.db')
    cursor = conn.cursor()
    
    # Enhanced users table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT UNIQUE NOT NULL,
            name TEXT NOT NULL,
            password_hash TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            is_premium BOOLEAN DEFAULT 0,
            stripe_customer_id TEXT,
            subscription_status TEXT DEFAULT 'trial',
            subscription_start_date TIMESTAMP,
            next_billing_date TIMESTAMP,
            trial_start_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            trial_end_date TIMESTAMP,
            scans_used INTEGER DEFAULT 0,
            total_scans_ever INTEGER DEFAULT 0,
            last_login TIMESTAMP
        )
    ''')
    
    # Scan history table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS scan_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            scan_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            result_rating TEXT,
            ingredients_found TEXT,
            image_name TEXT,
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    ''')
    
    conn.commit()
    conn.close()

# Initialize database
init_db()

# Helper functions
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

def get_user_data(user_id):
    conn = sqlite3.connect('foodfixr.db')
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    cursor.execute('SELECT * FROM users WHERE id = ?', (user_id,))
    user = cursor.fetchone()
    
    conn.close()
    return dict(user) if user else None

def calculate_trial_time_left(trial_start_date):
    if isinstance(trial_start_date, str):
        trial_start = datetime.strptime(trial_start_date, '%Y-%m-%d %H:%M:%S')
    else:
        trial_start = trial_start_date
    
    trial_end = trial_start + timedelta(hours=48)
    now = datetime.now()
    
    if now >= trial_end:
        return "0h 0m", True, 0, 0
    
    time_left = trial_end - now
    hours = int(time_left.total_seconds() // 3600)
    minutes = int((time_left.total_seconds() % 3600) // 60)
    
    return f"{hours}h {minutes}m", False, hours, minutes

def calculate_renewal_days(next_billing_date):
    if not next_billing_date:
        return None
    
    if isinstance(next_billing_date, str):
        billing_date = datetime.strptime(next_billing_date, '%Y-%m-%d %H:%M:%S')
    else:
        billing_date = next_billing_date
    
    now = datetime.now()
    days_left = (billing_date - now).days
    
    return max(0, days_left)

# AUTHENTICATION ROUTES
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form.get('email', '').strip().lower()
        password = request.form.get('password', '')
        
        if not email or not password:
            flash('Please enter both email and password', 'error')
            return render_template('login.html')
        
        conn = sqlite3.connect('foodfixr.db')
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM users WHERE email = ?', (email,))
        user = cursor.fetchone()
        
        if user and check_password_hash(user['password_hash'], password):
            # Update last login
            cursor.execute('UPDATE users SET last_login = ? WHERE id = ?', 
                         (datetime.now(), user['id']))
            conn.commit()
            
            # Set session
            session.permanent = True
            session['user_id'] = user['id']
            session['user_email'] = user['email']
            session['user_name'] = user['name']
            session['is_premium'] = bool(user['is_premium'])
            session['scans_used'] = user['scans_used']
            session['stripe_customer_id'] = user['stripe_customer_id']
            
            flash('Welcome back to FoodFixr!', 'success')
            conn.close()
            return redirect(url_for('index'))
        else:
            flash('Invalid email or password', 'error')
            conn.close()
    
    return render_template('login.html')

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        name = request.form.get('name', '').strip()
        email = request.form.get('email', '').strip().lower()
        password = request.form.get('password', '')
        confirm_password = request.form.get('confirm_password', '')
        
        # Validation
        if not all([name, email, password, confirm_password]):
            flash('All fields are required', 'error')
            return render_template('register.html')
        
        if password != confirm_password:
            flash('Passwords do not match', 'error')
            return render_template('register.html')
        
        if len(password) < 6:
            flash('Password must be at least 6 characters long', 'error')
            return render_template('register.html')
        
        if len(name) < 2:
            flash('Name must be at least 2 characters long', 'error')
            return render_template('register.html')
        
        conn = sqlite3.connect('foodfixr.db')
        cursor = conn.cursor()
        
        # Check if email already exists
        cursor.execute('SELECT id FROM users WHERE email = ?', (email,))
        if cursor.fetchone():
            flash('An account with this email already exists', 'error')
            conn.close()
            return render_template('register.html')
        
        # Create new user with trial period
        password_hash = generate_password_hash(password)
        trial_start = datetime.now()
        trial_end = trial_start + timedelta(hours=48)
        
        cursor.execute('''
            INSERT INTO users (name, email, password_hash, trial_start_date, trial_end_date, last_login)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (name, email, password_hash, trial_start, trial_end, trial_start))
        
        user_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        # Auto-login after registration
        session.permanent = True
        session['user_id'] = user_id
        session['user_email'] = email
        session['user_name'] = name
        session['is_premium'] = False
        session['scans_used'] = 0
        session['stripe_customer_id'] = None
        
        flash(f'Welcome to FoodFixr, {name}! Your free trial has started.', 'success')
        return redirect(url_for('index'))
    
    return render_template('register.html')

@app.route('/logout')
def logout():
    user_name = session.get('user_name', 'User')
    session.clear()
    flash(f'Goodbye {user_name}! You have been logged out.', 'info')
    return redirect(url_for('login'))

# MAIN ROUTES
@app.route('/')
@login_required
def index():
    user_data = get_user_data(session['user_id'])
    if not user_data:
        return redirect(url_for('logout'))
    
    # Calculate trial status
    trial_time_left, trial_expired, trial_hours, trial_minutes = calculate_trial_time_left(user_data['trial_start_date'])
    
    # Update session with latest data
    session['scans_used'] = user_data['scans_used']
    session['is_premium'] = bool(user_data['is_premium'])
    
    return render_template('scanner.html', 
                         trial_time_left=trial_time_left,
                         trial_expired=trial_expired,
                         user_name=user_data['name'])

@app.route('/account')
@login_required
def account():
    user_data = get_user_data(session['user_id'])
    if not user_data:
        return redirect(url_for('logout'))
    
    # Calculate trial time left
    trial_time_left, trial_expired, trial_hours, trial_minutes = calculate_trial_time_left(user_data['trial_start_date'])
    
    # Calculate renewal days for premium users
    days_until_renewal = None
    if user_data['is_premium'] and user_data['next_billing_date']:
        days_until_renewal = calculate_renewal_days(user_data['next_billing_date'])
    
    # Format dates
    created_date = datetime.strptime(user_data['created_at'], '%Y-%m-%d %H:%M:%S')
    formatted_created_date = created_date.strftime('%B %d, %Y')
    
    trial_start = datetime.strptime(user_data['trial_start_date'], '%Y-%m-%d %H:%M:%S')
    formatted_trial_start = trial_start.strftime('%B %d, %Y')
    
    # Format subscription dates for premium users
    subscription_start_formatted = None
    next_billing_formatted = None
    
    if user_data['is_premium']:
        if user_data['subscription_start_date']:
            sub_start = datetime.strptime(user_data['subscription_start_date'], '%Y-%m-%d %H:%M:%S')
            subscription_start_formatted = sub_start.strftime('%B %d, %Y')
        
        if user_data['next_billing_date']:
            next_billing = datetime.strptime(user_data['next_billing_date'], '%Y-%m-%d %H:%M:%S')
            next_billing_formatted = next_billing.strftime('%B %d, %Y')
    
    return render_template('account.html',
                         user_name=user_data['name'],
                         user_created_date=formatted_created_date,
                         total_scans_ever=user_data['total_scans_ever'],
                         trial_start_date=formatted_trial_start,
                         trial_time_left=trial_time_left,
                         trial_expired=trial_expired,
                         trial_hours_left=trial_hours,
                         trial_minutes_left=trial_minutes,
                         subscription_status=user_data['subscription_status'],
                         subscription_start_date=subscription_start_formatted,
                         next_billing_date=next_billing_formatted,
                         days_until_renewal=days_until_renewal,
                         billing_portal_url='/billing-portal')

# SCAN PROCESSING ROUTE (Updated)
@app.route('/', methods=['POST'])
@login_required
def process_scan():
    user_data = get_user_data(session['user_id'])
    if not user_data:
        return redirect(url_for('logout'))
    
    # Check if user can scan
    if not user_data['is_premium'] and user_data['scans_used'] >= 10:
        flash('You have used all your free scans. Please upgrade to continue.', 'error')
        return redirect(url_for('upgrade'))
    
    # Check if trial expired
    _, trial_expired, _, _ = calculate_trial_time_left(user_data['trial_start_date'])
    if not user_data['is_premium'] and trial_expired:
        flash('Your free trial has expired. Please upgrade to continue scanning.', 'error')
        return redirect(url_for('upgrade'))
    
    # Process the scan (your existing scan processing logic here)
    # For now, I'll create a mock result
    result = {
        'rating': 'Safe',
        'matched_ingredients': {
            'sugar': ['organic cane sugar'],
            'gmo': [],
            'trans_fat': [],
            'excitotoxins': [],
            'corn': []
        }
    }
    
    # Update scan count in database
    conn = sqlite3.connect('foodfixr.db')
    cursor = conn.cursor()
    
    new_scans_used = user_data['scans_used'] + 1 if not user_data['is_premium'] else user_data['scans_used']
    new_total_scans = user_data['total_scans_ever'] + 1
    
    cursor.execute('''
        UPDATE users 
        SET scans_used = ?, total_scans_ever = ?
        WHERE id = ?
    ''', (new_scans_used, new_total_scans, session['user_id']))
    
    # Save scan to history
    cursor.execute('''
        INSERT INTO scan_history (user_id, result_rating, ingredients_found)
        VALUES (?, ?, ?)
    ''', (session['user_id'], result.get('rating', ''), str(result.get('matched_ingredients', {}))))
    
    conn.commit()
    conn.close()
    
    # Update session
    session['scans_used'] = new_scans_used
    
    # Calculate updated trial status
    trial_time_left, trial_expired, _, _ = calculate_trial_time_left(user_data['trial_start_date'])
    
    return render_template('scanner.html', 
                         result=result,
                         trial_time_left=trial_time_left,
                         trial_expired=trial_expired,
                         user_name=user_data['name'])

# ADDITIONAL ROUTES
@app.route('/upgrade')
@login_required
def upgrade():
    return render_template('upgrade.html')

@app.route('/history')
@login_required
def history():
    conn = sqlite3.connect('foodfixr.db')
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    cursor.execute('''
        SELECT * FROM scan_history 
        WHERE user_id = ? 
        ORDER BY scan_date DESC 
        LIMIT 50
    ''', (session['user_id'],))
    
    scans = cursor.fetchall()
    conn.close()
    
    return render_template('history.html', scans=scans)

@app.route('/billing-portal')
@login_required
def billing_portal():
    # This would redirect to Stripe Customer Portal
    # For now, just show a placeholder
    flash('Billing portal integration coming soon!', 'info')
    return redirect(url_for('account'))

@app.route('/cancel-subscription')
@login_required
def cancel_subscription():
    # Handle subscription cancellation
    conn = sqlite3.connect('foodfixr.db')
    cursor = conn.cursor()
    
    cursor.execute('''
        UPDATE users 
        SET subscription_status = 'cancelled', is_premium = 0
        WHERE id = ?
    ''', (session['user_id'],))
    
    conn.commit()
    conn.close()
    
    session['is_premium'] = False
    flash('Your subscription has been cancelled. You can continue using your free trial.', 'info')
    return redirect(url_for('account'))

# DEMO USER SETUP
def create_demo_user():
    conn = sqlite3.connect('foodfixr.db')
    cursor = conn.cursor()
    
    demo_email = 'demo@foodfixr.com'
    
    # Check if demo user exists
    cursor.execute('SELECT id FROM users WHERE email = ?', (demo_email,))
    if cursor.fetchone():
        conn.close()
        return
    
    # Create demo user
    password_hash = generate_password_hash('demo123')
    trial_start = datetime.now() - timedelta(hours=2)  # Started 2 hours ago
    trial_end = trial_start + timedelta(hours=48)
    
    cursor.execute('''
        INSERT INTO users (name, email, password_hash, trial_start_date, trial_end_date, 
                          scans_used, total_scans_ever, last_login)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', ('Demo User', demo_email, password_hash, trial_start, trial_end, 3, 15, datetime.now()))
    
    demo_user_id = cursor.lastrowid
    
    # Add sample scan history
    sample_scans = [
        ('Safe', '{"sugar": ["organic cane sugar"]}', datetime.now() - timedelta(hours=1)),
        ('Proceed carefully', '{"corn": ["high fructose corn syrup"]}', datetime.now() - timedelta(minutes=30)),
        ('Danger', '{"trans_fat": ["partially hydrogenated oil"]}', datetime.now() - timedelta(minutes=10))
    ]
    
    for rating, ingredients, scan_date in sample_scans:
        cursor.execute('''
            INSERT INTO scan_history (user_id, result_rating, ingredients_found, scan_date)
            VALUES (?, ?, ?, ?)
        ''', (demo_user_id, rating, ingredients, scan_date))
    
    conn.commit()
    conn.close()
    print("Demo user created: demo@foodfixr.com / demo123")

if __name__ == '__main__':
    create_demo_user()
    app.run(debug=True)
